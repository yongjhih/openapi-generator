# coding: utf-8
# -*- coding: future_fstrings -*-

import asyncio
import ssl
import time
import uuid
from typing import Any, Dict, List, Optional, NewType, TypeVar

import aiohttp
import jsonpickle
import jsontofu
from aiohttp.client import ClientSession
from aiohttp.client_ws import ClientWebSocketResponse
from aiohttp.http_websocket import WSMessage
from dataclasses import dataclass
from requests.exceptions import HTTPError

#from .* import *

class JwtAuth(aiohttp.helpers.BasicAuth):
    def __init__(self, access_token: str):
        self.access_token = access_token
        self.jwt = f"Bearer {self.access_token}"

    def encode(self) -> str:
        return self.jwt


class Rests():
    def __init__(self, base_url: str, session: aiohttp.ClientSession = aiohttp.ClientSession()):
        self.base_url = base_url
        self.session = session

    def url(self, url: str) -> str:
        return url if url.startswith('http://') or url.startswith('https://') else f'{self.base_url}/{url}'

    async def get(self, url: str) -> ClientResponse:
        return await self.session.get(self.url(url))

    async def post(self, url: str, data: Optional[Dict] = None) -> ClientResponse:
        return await self.session.post(url=self.url(url), data=data)

    async def put(self, url: str, data: Optional[Dict] = None) -> ClientResponse:
        return await self.session.put(url=self.url(url), data=data)

    async def delete(self, url: str) -> ClientResponse:
        return await self.session.delete(self.url(url))

    async def head(self, url: str) -> ClientResponse:
        return await self.session.head(self.url(url))

    async def options(self, url: str) -> ClientResponse:
        return await self.session.head(self.url(url))

    async def patch(self, url: str, data: Optional[Dict] = None) -> ClientResponse:
        return await self.session.head(url=self.url(url), data=data)


class {{classname}}(Rests):
    {{#description}}
    """
    {{description}}
    """
    {{/description}}

    def __init__(self, base_url: str = '{{basePath}}', session: aiohttp.ClientSession = aiohttp.ClientSession()):
        super().__init__(base_url, session)

{{#operations}}{{#operation}}
{{#vendorExtensions}}
    async def {{operationId}}(self{{#pathParams}}, {{paramName}}{{#dataType}}: {{^required}}Optional[{{/required}}{{dataType}}{{/dataType}}{{^required}}]{{/required}}{{#defaultValue}} = {{defaultValue}}{{/defaultValue}}{{^defaultValue}}{{^required}} = None{{/required}}{{/defaultValue}}{{/pathParams}}{{#queryParams}}, {{paramName}}{{#dataType}}: {{^required}}Optional[{{/required}}{{dataType}}{{/dataType}}{{^required}}]{{/required}}{{#defaultValue}} = {{defaultValue}}{{/defaultValue}}{{^defaultValue}}{{^required}} = None{{/required}}{{/defaultValue}}{{/queryParams}}) -> {{#returnType}}{{returnType}}{{/returnType}}{{^returnType}}None{{/returnType}}:
        """
        {{#summary}}
        {{summary}}
        {{/summary}}

        {{httpMethod}} {{path}}

{{#pathParams}}
        :param {{dataType}} {{paramName}}:{{#description}} {{{description}}}{{/description}}{{#required}} (required){{/required}}{{#optional}}(optional){{/optional}}
{{/pathParams}}

{{#queryParams}}
        :param {{dataType}} {{paramName}}:{{#description}} {{{description}}}{{/description}}{{#required}} (required){{/required}}{{#optional}}(optional){{/optional}}
{{/queryParams}}

        :return: {{#returnType}}{{returnType}}{{/returnType}}{{^returnType}}None{{/returnType}}
        """
        return await self.{{lower_http_method}}(f"{{path}}"{{#hasQueryParams}}, { {{/hasQueryParams}}{{#queryParams}} "{{paramName}}": {{paramName}}, {{/queryParams}}{{#hasQueryParams}} } {{/hasQueryParams}})
{{/vendorExtensions}}
{{/operation}}{{/operations}}
